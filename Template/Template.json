{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"boilerplate": {
		"prefix": "Woafi",
		"body": [
			"#include <bits/stdc++.h>",
      		"using namespace std;\n",
      		"// Typedefs for common data types",
      		"typedef long long ll;",
      		"typedef double dl;",
      		"typedef vector<int> vi;",
      		"typedef vector<ll> vl;",
      		"typedef pair<int, int> pii;",
      		"typedef pair<double, double> pdd;",
      		"typedef vector<pii> vpii;\n",
      		"typedef vector<int> :: iterator vit;",
      		"typedef set<int> :: iterator sit;\n",
			"// Frequently used macros for loops",
			"#define endl '\\n'",
			"#define SZ(x) (int)(x).size()",
			"#define ALL(v) v.begin(), v.end()",
			"#define F first",
			"#define S second",
			"#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n",
			

			"template < typename F, typename S >",
			"ostream& operator << ( ostream& os, const pair< F, S > & p ) {",
			"    return os << \"(\" << p.first << \", \" << p.second << \")\";",
			"}\n",
			"template < typename T >",
			"ostream &operator << ( ostream & os, const vector< T > &v ) {",
			"    os << \"{\";",
			"    for(auto it = v.begin(); it != v.end(); ++it) {",
			"        if( it != v.begin() ) os << \", \";",
			"        os << *it;",
			"    }",
			"    return os << \"}\";",
			"}\n",
			"template < typename T >",
			"ostream &operator << ( ostream & os, const set< T > &v ) {",
			"    os << \"[\";",
			"    for(auto it = v.begin(); it != v.end(); ++it) {",
			"        if( it != v.begin() ) os << \", \";",
			"        os << *it;",
			"    }",
			"    return os << \"]\";",
			"}\n",
			"template < typename T >",
			"ostream &operator << ( ostream & os, const multiset< T > &v ) {",
			"    os << \"[\";",
			"    for(auto it = v.begin(); it != v.end(); ++it) {",
			"        if( it != v.begin() ) os << \", \";",
			"        os << *it;",
			"    }",
			"    return os << \"]\";",
			"}\n",
			"template < typename F, typename S >",
			"ostream &operator << ( ostream & os, const map< F, S > &v ) {",
			"    os << \"[\";",
			"    for(auto it = v.begin(); it != v.end(); ++it) {",
			"        if( it != v.begin() ) os << \", \";",
			"        os << it -> first << \" = \" << it -> second ;",
			"    }",
			"    return os << \"]\";",
			"}\n",
			"#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)\n",
			"void faltu () {",
			"    cerr << endl;",
			"}\n",
			"template <typename T>",
			"void faltu( T a[], int n ) {",
			"    for(int i = 0; i < n; ++i) cerr << a[i] << ' ';",
			"    cerr << endl;",
			"}\n",
			"template <typename T, typename ... hello>",
			"void faltu( T arg, const hello &... rest) {",
			"    cerr << arg << ' ';",
			"    faltu(rest...);",
			"}\n"
			
			"int main() {",
        	"    optimize();\n",
      		"    $1\n",
      		"    return 0;",
      		"}"
		],
		"description": "this is a boilerplate"
	}
}


	
	  
	
  
  